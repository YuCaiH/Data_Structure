# 引入：数据结构在学什么

- 如何用程序代码把现实世界的问题**信息化**

数字财富(微信余额等)：用浮点型变量实现

线上排队(取餐号等)：用数组实现，还有...

交友(网络交友网友互相关注)：初学无头绪...

- 如何用计算机高效地处理这些信息从而创造价值

**计算机/手机**

底层（计算机组成原理）：计算机硬件 —— 中央处理器(CPU)、内存、主板……

操作系统 —— Linux、安卓、Windows、iOS……

上层（数据结构）：应用软件 —— 微信、淘宝、美团、高德地图……

![](E:\数据结构\相关图表\信息化世界.jpg)

#  1.  绪论

**需要具备的知识：C/C++语言**

1. 什么是分支、循环（if/else,for,while）
2. 什么是数组
3. 什么是函数
4. 什么是指针，什么是地址
5. 什么是struct结构体

## 1.1.数据结构

### 1.1.1.数据结构的基本概念

**数据**：数据是信息的载体，是描述客观事物属性的**数、字符以及所有能输入到计算机中并被计算机程序识别和处理的符号的集合**。数据是计算机程序加工的原料（计算机专业人员用数据描述世界）

**早期计算机处理数据 —— 用于处理纯数值型问题**：世界上第一台通用计算机ENIAC是战争的产物（用于快速计算弹道轨迹等复杂的数学计算问题）

**现代计算机处理的数据 —— 经常处理非数值型问题**

对于非数值型的问题：

1. 关心每个个体的具体信息

   数据元素 、数据项—— 描述一个个体

   **数据元素、数据项：**

   数据元素是数据的基本单位，通常作为一个整体进行考虑和处理

   一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位

   ![](E:\数据结构\相关图表\数据元素、数据项.jpg)

   **数据对象**：具有相同性质的数据元素的集合，是数据的一个子集

   ![](E:\数据结构\相关图表\数据对象.jpg)

2. 关心个体与个体之间的关系

   数据结构 —— 个体之间的关系

   **数据结构**：是相互之间存在一种或多种特定关系的数据元素的集合

   <注意区分数据对象和数据结构> 

   <同样的数据元素，可以根据不同的关系标准组成不同的数据结构>

   <不同的数据元素，可以组成相同的数据结构（微博粉丝排行榜：线性关系、微博好友关系：网状关系）>

**数据结构这门课着重关注的是数据元素之间的关系，和对这些数据元素操作，而不关心具体的数据项内同**

### 1.1.2.数据结构的三要素：

<逻辑结构和数据的运算是定义一种数据结构，物理结构是实现这种数据结构>

1. **逻辑结构**

   - **集合结构**

     各个元素同属于一个集合，别无其它关系（非重点）

   - **线性结构** —— 一对一

     ![](E:\数据结构\相关图表\线性结构.jpg)

     除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继

   - **树形结构** —— 一对多

   - **图状结构** —— 多对多

2. **数据的运算**

   针对于某种逻辑结构，结合实际要求，定义**基本运算**

   eg.针对线性结构经常用到的基本运算有

   - 查找第i个数据元素
   - 在第i个位置插入新的数据元素
   - 删除第i个位置的数据元素

3. **物理结构**（存储结构）：在计算机内表示出数据元素的逻辑关系

   <链式存储、索引存储和散列存储都是非顺序存储(离散存储)>

   - **顺序存储结构**（需要一整片连续的空间）

     <以线性存储结构为例>

     *把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中*，元素间的关系由存储单元的邻接关系来体现

     ![](E:\数据结构\相关图表\顺序存储.jpg)

   - **链式存储结构**

     *逻辑上相邻的元素在物理位置上可以不相邻*，借助指示元素存储地址的指针来表示元素之间的逻辑关系

     ![](E:\数据结构\相关图表\链式存储结构.jpg)

   - **索引存储结构**

     在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）

     ![](E:\数据结构\相关图表\索引存储结构.jpg)

   - **散列存储结构**

     根据元素的关键字直接计算出该元素的存储地址，又称哈希存储

   **补充**：**数据类型、抽象数据类型**

   **数据类型**：是一个**值的集合**和**定义在此集合上的一组操作**的总称

   1. **原子类型**：其值不可再分的数据类型

      ![](E:\数据结构\相关图表\原子数据类型.jpg)

   2. **结构类型**其值可以再分解为若干成分（分量），且分量之间具有一定的逻辑关系的数据类型

      ![](E:\数据结构\相关图表\结构数据类型.jpg)

   **抽象数据类型**（ADT）：是**抽象数据组织**及**与之相关的操作**

   

   **知识回顾与重要考点**

   ![](E:\数据结构\相关图表\1.1知识回顾.jpg)

## 1.2.算法

### 1.2.1.算法的基本概念

- **什么是算法**

  ![](E:\数据结构\相关图表\算法.jpg)

  算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作

- **算法的五个特质**

  1. **有穷性**：一个算法必须总在执行有穷步骤之后结束，且每一步都可在又穷时间内完成

     **算法必须是有穷的**(用有限的步骤解决某个特定的问题)，而**程序可以是无穷的**(eg.微信是程序不是算法,它能无穷无尽地运行下去)

  2. **确定性**：算法中每条指令必须有确切的含义（无歧义），对于相同的输入只能得到相同的输出

  3. **可行性**：算法描述中地操作都可以通过已经实现的基本运算执行有限次来实现

  4. **输入**：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合

  5. **输出**：一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量

- **“好”算法的特质**

  1. **正确性**：算法能够正确地求解问题

  2. **可读性**：可读性强，易于理解（提供注释）

  3. **健壮性**：当输入非法数据的时候，算法能够适当地做出反应或进行处理，而不会产生莫名其妙的结果

  4. **高效率和低存储量需求**

     **时间复杂度**   &    **空间复杂度**

**知识回顾与重要考点**

![](E:\数据结构\相关图表\1.2知识回顾.jpg)

### 1.2.2.算法的时间复杂度

时间复杂度：程序的执行次数，而不是运行所花的时间

只保留最高阶，且系数为1

用大O表示法（大O表示“同阶”，同等数量级）

时间复杂度判断（常对幂指阶）![](E:\数据结构\相关图表\时间复杂度判断.jpg)

**知识点总结**

![](E:\数据结构\相关图表\时间复杂度.jpg)

### 1.2.3.算法的空间复杂度

空间复杂度：变量的个数

函数的递归调用所带来的内存开销

![](E:\数据结构\相关图表\空间复杂度.jpg)

# 2. 线性表

![](E:\数据结构\相关图表\线性表.jpg)

## 2.1.线性表的定义与基本操作

### 2.1.1.线性表的定义

线性表是具有相同数据类型的n(n≥1)个数据元素的有限序列，其中n为表长，当n=0时线性表是空表

用L命名线性表，其一般表示为：L=(a1,a2,a3,...ai,ai+1,...,an)

**几个概念**

ai是线性表中的“第i个”元素在线性表中的位序（位序从1开始，数组下标从0开始）

a1是表头元素；an是表尾元素

除第一个元素外，每个元素有且只有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继

### 2.1.2.线性表的基本操作

- **InitList(&L)**：初始化表。后遭一个空的线性表L，分配内存空间      <O(1)>
- **DestroyList(&L)**：销毁操作。销毁线性表，并释放线性表L所占的内存空间      <O(1)>

- **ListInsert(&L,i,e)**：插入操作。在表L中的第i个位置上插入指定元素e      <O(n)>
- **ListDelete(&L,i,&e)**：删除操作。删除表L中第i个位置上的元素，并用e返回删除元素的值      <O(n)>

- **LocateElem(L,e)**：按值查找操作。在表L中查找具有给定关键字值的元素      <O(n)>
- **GetElem(L,i)**：按位查找操作。获取表L中第i个位置的元素的值      <O(1)>

- **Length(L)**：求表长。返回线性表L的长度，即L中数据元素的个数      <O(1)>
- **PrintList/DispList**：输出操作。按前后顺序输出线性表L的所有元素值      <O(n)>
- **ListEmpty(L)**：判空操作。若L为空表，则返回true，否则返回false          <O(1)>

**Tips**

- 对数据的操作 —— 创销、增删
- C语言函数的定义 —— <返回值类型> 函数名 (<参数1类型>参数1，<参数2类型>参数2......)
- 其他基本操作：实际开发中可根据实际需求定义其他基本操作
- 函数名和参数的形式、命名都可以看遍（命名要有可读性）
- **什么时候要传入引用“&”** —— 对参数的修改结果需要**“带回来”**（传址调用）

为什么要实现对数据结构的基本操作？

- 团队合作编程，你定义的数据结构要让别人能够很方便的使用（封装）
- 将常用的操作/运算封装成函数，避免重复工作，降低出错风险



**线性表知识回顾**

![](E:\数据结构\相关图表\2.1线性表.jpg)

## 2.2.顺序表

### 2.2.1.顺序表的定义

顺序表 ——  用顺序存储的方式实现线性表顺序存储

顺序表用存储位置的相邻来体现数据元素之间的逻辑关系

![](E:\数据结构\相关图表\顺序表存储.jpg)

```c
typedef struct{
    int num;
    int people;
}Customer;
sizeof(Customer)=8B
```



**顺序表的实现 —— 静态分配**

```c
#define MaxSize 10              //定义最大长度
typedef struct{
    ElemType data[MaxSize];     //用静态的“数组”存放数据元素
    //静态数组：数组的长度大小一旦确定之后就不能再改变
    //给各个数据元素分配连续的存储空间，大小为 MaxSize*sizeof(ElemType)
    int length;                 //顺序表的当前长度
}SqList;                        //顺序表的类型定义（静态分配方式）
```

```c
#include <stdio.h>
#define MaxSize 10             
typedef struct{
    int data[MaxSize];    
    int length;                
}SqList;   

void InitList(SqList &L){
    for(int i=0;i<MaxSize;i++)
        L.data[i]=0;
    L.length=0; 
}

int main()
{
    SqList L;          //声明一个顺序表
    InitList(L);
    
    return 0;
}
```

**顺序表的实现 —— 动态分配**

```c
#define InitSize 10       //顺序表的初始长度
typedef struct{ 
    ElemType *data;       //指示动态分配数组的指针
    int MaxSize;          //顺序表的最大容量
    int length;           //顺序表的当前长度
}SeqList;                 //顺序表的类型定义（动态分配方式）
```

**动态的申请和释放内存空间**

C ——  malloc、free函数

malloc可以申请一整片连续的内存空间

```c
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);
        //malloc函数返回一个指针，需要强制转型为你定义的数据元素类型指针，所以有(ElemType*)
```

顺序表的特点

- **随机访问，既可以在O(1)时间内找到第i个元素**
- 存储密度高，每个节点只存储数据元素（链式存储的每个节点除了要存储数据元素还需要耗费一定空间存储指针）
- 拓展容量不方便
- 插入删除元素不方便



**知识点总结**

![](E:\数据结构\相关图表\顺序表.jpg)

### 2.2.2.顺序表的基本操作

**顺序表的插入和删除**

1. **ListInsert(&L,i,e)**：插入操作。在表中的第i个位置插入指定元素e![](E:\数据结构\相关图表\顺序表插入.png)

   ```c
   typedef int ElemType
   #define MaxSize 10               //定义最大长度
   typedef struct{                 
       ElemType data[MaxSize];      //用静态的“数组”存放数据元素
       int length;                  //顺序表的当前长度
   }SqList;                         //顺序表的类型定义
   
   bool ListInsert(SqList &L,int i,int e){
       if(i<1||i>L.length+1)
           return false;
       if(L.length>=Maxsize)     //判断顺序表是否已经满了
           return false;
       for(int j=L.length;j>=i;j--)
           L.data[j]=L.data[j-1];
       L.data[j-1]=e;
       L.length++;
       return true;
   }
   
   int main()
   {
       SqList L;
       InitList(L);
       ...
       ListInsert(L,3,3);
       return 0;
   }
   ```

   插入操作的时间复杂度：

   最好情况：O(1)      最坏情况：O(n)        平均情况：O(n/2)

2. **ListDelete(&L,i,&e)**：删除操作。删除表中的第i个位置的元素，并返回e(该元素值)

   ```c
   typedef int ElemType
   #define MaxSize 10               //定义最大长度
   typedef struct{                 
       ElemType data[MaxSize];      //用静态的“数组”存放数据元素
       int length;                  //顺序表的当前长度
   }SqList;                         //顺序表的类型定义
   
   bool ListDelete(SqList &L,int i,int e){
       if(i<1||i>L.length+1)
           return false;
       e=L.data[i-1]
       for(int j=i;j=L.length;j++)
           L.data[j-1]=L.data[j];
       L.length--;
       return true;
   }
   
   int main()
   {
       SqList L;
       InitList(L);
       ...
       return 0;
   }
   ```

   删除操作的时间复杂度：

   最好情况：O(1)      最坏情况：O(n)        平均情况：O((n-1) /2)

知识总结

![](E:\数据结构\相关图表\顺序表的插入和删除基本操作.png)

**顺序表的查找**

1. 按位查找

   **GetElem(L,i)**：按位查找操作。获取表L中第i个位置的元素的值       <O(1)>

   静态分配方式

   ```c
   typedef int ElemType
   #define MaxSize 10
   typedef struct{
       ElemType data[MaxSize];
       int length;
   }SqList;
   
   ElemType GetElem(SqList L,int i){
       return L.data[i-1];
   }
   ```

   动态分配方式

   ```c
   typedef int ElemType
   #define InitSize 10
   typedef struct{
       ElemType *data;   //指示动态分配数组的指针
       int MaxSize;
       int length;
   }SeqList;
   
   ElemType GetElem(SeqList L,int i){
       return L.data[i-1];
   }
   ```

   ![](E:\数据结构\相关图表\顺序表按位查找动态存储.png)

2. 按值查找

   **LocateElem(L,e)**：按值查找操作。在表L中查找具有给定关键字值的元素  <O(n)>

   ```c
   typedef int ElemType
   #define InitSize 10
   typedef struct{
       ElemType *data;   //指示动态分配数组的指针
       int MaxSize;
       int length;
   }SeqList;
   
   int LocateElem(SqList L,ElemType e){
       for(int i=0;i<L.length;i++)
           if(L.data[i]==e)
               return i+1;
       return 0;
   }
   ```

## 2.3.链表

### 2.3.1.单链表

**单链表的定义**

![](E:\数据结构\相关图表\单链表的定义.png)

单链表每个结点除了存放数据元素外，还要存储指向下一个结点的指针

优点：不要求大片连续的空间，改变容量方便

缺点：不可随机存取，需要耗费一定空间存放指针

```c
struct LNode{             //定义单链表节点类型
    ElemType data;        //每个节点存放一个数据元素
    struct LNode *next;   //定义指针变量next指向下一个节点
};
```

```c
struct LNode *p=(struct LNode*)malloc(sizeof(struct LNode));
//增加一个新的结点：在内存中申请一个结点所需空间，并用指针p指向这个结点
```

上面的方法每增加一个新的结点都需要带上 struct LNode 这个关键字，用typedef解决

```c
//typedef <数据类型> <别名>
//eg. typedef int zhengshu;
typedef struct LNode LNode;
LNode *p=(LNode*)malloc(sizeof(LNode));
```

```c
typedef struct LNode{          
    ElemType data;       
    struct LNode *next;  
}LNode,*LinkList;
//等价于
struct LNode{           
    ElemType data;        
    struct LNode *next;  
};
typedef struct LNode LNode;
typedef struct LNode *LinkList;
```

![](E:\数据结构\相关图表\单链表声明指针.png)

![](E:\数据结构\相关图表\LinkList 和 LNode.jpg)

![](E:\数据结构\相关图表\不带头结点的单链表.png)

![](E:\数据结构\相关图表\带头结点的单链表.png)

带头结点的单链表写代码更方便

知识总结

![](E:\数据结构\相关图表\单链表定义知识总结.png)

**单链表的插入和删除**

![](E:\数据结构\相关图表\单链表的插入和删除.png)

**按位序插入**

- 带头结点

  ListInsert(&L,i,e)：插入操作。在表中第i个位置上插入指定元素e

  ![image-20230618153925199](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618153925199.png)

  ![image-20230618154349597](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618154349597.png)

  

  ![image-20230618154527689](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618154527689.png)

  

- 不带头结点

  ListInsert(&L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e

  

  ![17765fc77f835c1a409ac1cae6c100e](C:\Users\于采卉\AppData\Local\Temp\WeChat Files\17765fc77f835c1a409ac1cae6c100e.jpg)

- 指定结点的后插操作 —— O(1)

  ![image-20230618160525520](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618160525520.png)

  ![image-20230618160626651](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618160626651.png)

- 指定结点的前插操作

  ![image-20230618161005745](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618161005745.png)
  时间复杂度为O(n)

  

  ![image-20230618160831447](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618160831447.png)
  时间复杂度为O(1)

**按位序删除**

- 带头节点 —— O(n)

  ![image-20230618161357585](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618161357585.png)

    ![image-20230618161536655](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618161536655.png)

- 指定结点的删除

  ![image-20230618161713531](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618161713531.png)

![image-20230618161915262](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618161915262.png)

**单链表的查找(带头结点)**

1. **按位查找 —— O(n)**

   ![image-20230618162153119](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618162153119.png)

   ![image-20230618162314587](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618162314587.png)

   ![image-20230618162831337](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618162831337.png)

   

2. **按值查找**

   ![image-20230618162204694](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618162204694.png)

   ![image-20230618165414019](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618165414019.png)

### 2.3.2双链表

单链表无法逆向检索，有时候不太方便；双链表可进可退，存储密度更低一点

```c
typedef struct LNode{            //定义双链表结点类型
    ElemType data;               //数据域
    struct LNode *prior,*next;   //前驱和后继指针
}DNode,*DLinkList;
```

# 3.栈和队列

## 3.1.栈

### 3.1.1.栈的基本概念

栈是一种只允许在一端进行插入或删除操作的线性表<比如垒起来的盘子，吃烤串>

重要术语：栈顶、栈底、空栈

栈的特点：后进先出（LIFO）

![](E:\数据结构\相关图表\栈的特点.png)

**栈相关的基本操作**

- **InitStack(&S)**：初始化栈。构造一个空栈，分配内存空间
- **DestroyStack(&S)**：销毁栈。销毁并释放栈S所占内存空间

- **Push(&S,x)**：进栈，若栈S未满，则将x加入使之成为新栈顶
- **Pop(&S,&x)**：出栈，若栈S非空，则弹出栈顶元素，并用x返回

- **GetTop(S,&x)**：读栈顶元素。若栈S非空，则用x返回栈顶元素

其他常用操作

- **StackEmpty(S)**：判断一个栈是否为空。若S为空，则返回true，否则返回false

栈的常考类型：有哪些合法的出栈顺序

### 3.1.2.顺序栈的实现

初始化操作

```c
#define MaxSize 10             //定义栈中元素的最大个数
typedef struct{                 
    ElemType data[MaxSize];     //静态数组存放栈中元素
    int top;                    //栈顶指针
}SqStack;

void InitStack(SqStack &S)     //初始化栈
{ 
    S.top=-1;                   //初始化栈顶指针
}

void testStack()                 
{ 
    SqStack S;                 //声明一个顺序栈(分配空间)
    InitStack(S);
    ...后续操作...（增删改查）
}

bool StackEmpty(SqStack S)
{
    if(S.top==-1)           //栈空
        return true;
    else
        return false;
}
```

进栈操作

```c
bool Push(SqStack &S,ElemType x)
{
    if(S.top==MaxSize-1)          //栈满，报错
        return false;
    S.top = S.top+1;              //指针先加1
    S.data[S.top]=x;              //新元素入栈
    return true;
}
```

![](E:\数据结构\相关图表\顺序栈入栈.png)

出栈操作

```c++
bool Pop(SqStack &S,ElemType &x)
{
    if(S.top==-1)
        return false;
    x=S.data[S.top];
    S.top=S.top-1;
    return true;
}
```

![](E:\数据结构\相关图表\出栈操作.png)

读栈顶元素操作

```c++
bool GetTop(SqStack S,ElemType &x)
{
    if(S.top==-1)
        return false;
    x=S.data[S.top];
    return ture;
}
```

![](E:\数据结构\相关图表\初始化栈的另一种方式1.0.png)

![](E:\数据结构\相关图表\初始化栈的另一种方式2.0.png)

顺序栈的缺点：栈的大小不可变，导致空间利用率不高，可以用共享栈的方法解决这一问题

共享栈：两个栈共享同一片空间

```c
#define MaxSize 10              //定义栈中元素的最大个数
typedef struct{                 
    ElemType data[MaxSize];     //静态数组存放栈中元素
    int top0;                   //0号栈栈顶指针
    int top1;                   //1号栈栈顶指针
}ShStack;

void InitStack(ShStack &S)
{
    S.top0=-1;
    S.top1=MaxSize;
}
```

栈满的条件：top0+1=top1

**知识总结**

![](E:\数据结构\相关图表\顺序栈知识总结.png)

### 3.1.3.链栈

```c
typedef struct Linknode{
    ElemType data;             //数据域
    struct Linknode *next;     //指针域
}*LiStack;                     //栈类型定义
```

![](E:\数据结构\相关图表\链栈知识总结.png)

## 3.2.队列

### 3.2.1.队列的基本概念

队列是一种只允许在一端（队尾）进行插入(入队)，在另一端队头）进行删除操作(出队)的线性表

重要术语：队头、队尾、空队列

队列的特点：先进先出（FIFO）

**队列的基本操作**

- **InitQueue(&Q)**：初始化队列，构造一个空队列
- **DestroyQueue(&Q)**：销毁队列。销毁并释放队列Q所占的内存空间

- **EnQueue(&Q,x)**：入队，若队列Q未满，将x加入，使之成为新队尾
- **DeQueue(&Q,&x)**：出队，若队列Q非空，删除队头元素，并用x返回

- **GetHead(Q,&x)**：读队头元素，若队列Q非空，则将队头元素赋值给x

### 3.2.2.队列的顺序实现

```c
#define MaxSize 10         //定义队列中元素最大个数
typedef struct{  
    int front,rear;         //用静态数组存放队列元素
}SqQueue;                   //队头指针和队尾指针

//用静态数组存储表明需要连续的存储空间
//front指向队头元素，rear指向队尾元素的后一个位置（下一个应该插入的位置）

void InitQueue(SqQueue &Q){
    Q.rear=Q.front=0;
}
```

判断队空

```c
bool QueueEmpty(SqQueue Q){
    if(Q.rear==Q.front)
        return true;
    else
        return false;
}
```

入队操作

```c
bool EnQueue(SqQueue &Q,ElemType x){
    if((Q.rear+1)%MaxSize==Q.front)                       //Q.rear==MaxSize不是判断队列已满的条件
    //当队头有元素出队时，队尾指针仍然指向队尾，但其实有空位置
        return false;
    Q.data[Q.rear]=x;
    Q.rear=(Q.rear+1)%MaxSize; //队尾指针+1取模
    //利用取余运算让队尾指针指针的变化是从首到尾然后再回到首的循环
    return true;
}
//用模运算将存储空间在逻辑上变成“环状”，因此又叫循环队列
```

![](E:\数据结构\相关图表\循环队列.png)

为什么要牺牲掉一个存储单元：因为如果全部存满的话Q.rear==Q.front，但是判断队空的条件是Q.rear==Q.front，就会有冲突

出队操作

```c
bool DeQueue(SqQueue &Q,ElemType &x){
    if(Q.rear==Q.front)
        return false;
    x=Q.data[Q.front];
    Q.front=(Q.front+1)%MaxSize;  //队头指针后移
    return true;
}
```

获得头元素的值

```c
bool GetHead(SqQueue &Q,ElemType &x){
    if(Q.rear==Q.front)
        return false;
    x=Q.data[Q.front];
    return true;
}
```

**判断队空/队满的操作**

方案一

![](E:\数据结构\相关图表\方案一判断.png)

方案二

![](E:\数据结构\相关图表\方案二.png)

方案三

![](E:\数据结构\相关图表\方案三.png)

知识总结

![](E:\数据结构\相关图表\队列知识点总结.png)

### 3.2.3.队列的链式实现

```c
typedef struct LinkNode{       //链式队列结点
    ElemType data;
    struct LinkNode *next;
}LinkNode;

typedef struct{                 //链式队列
    LinkNode *front,*rear;      //队列的队头和队尾指针
}LinkQueue;
```

![image-20230618165844975](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618165844975.png)

![image-20230618165918303](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618165918303.png)

![image-20230618170055464](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618170055464.png)

![image-20230618170237218](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618170237218.png)

![image-20230618170303435](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618170303435.png)

![image-20230618170556997](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618170556997.png)

# 4.树与二叉树

## 4.1.树

### 4.1.1. 树的定义和基本用语

![image-20230609200001273](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609200001273.png)

**树的基本概念**

树：从树根生长，逐级分支

![image-20230609200317521](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609200317521.png)

空树：结点数为0的树

非空树的特性：

- 有且仅有一个根节点（只有根节点没有前驱）
- 没有后继结点的称为“叶子节点”（只有叶子结点没有后继）
- 有后继的结点称为“分支节点”
- 除了根结点外，任何一个节点都有且仅有一个前驱
- 每个结点可以有0个或多个后继

**定义**：树是n(n≥0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：
1）有且仅有一个特定的称为根的结点。
2）当n>1时，其余结点可分为 m（m>0）个**互不相交的有限集合**,每个集合本身又是一棵树，并且称为根节点的子树

![image-20230609214856947](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609214856947.png)

![image-20230609214913138](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609214913138.png)![image-20230609214924302](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609214924302.png)

树是一种递归定义的数据结构（任何一棵树都可以看作是由根结点和若干个不相交的子树构成）

**基本术语**

结点之间的关系描述

- 祖先节点
- 子孙节点
- 双亲结点（父节点）
- 孩子节点
- 兄弟节点（同一个爹）
- 堂兄弟结点（同一层）

- 两个结点之间的路径：只能从上往下
- 路径长度：经过了几条边路径就是多长

结点、树的属性描述

- 结点的层次（深度）—— 从上往下数（默认从1开始）
- 结点的高度 —— 从下往上数
- 树的高度（深度）—— 总共多少层
- **结点的度** —— 有几个孩子（分支）<叶子结点的度为0，非叶子结点的度大于0>
- **树的度** —— 各结点的度的最大值

有序树、无序树

- 有序树：逻辑上看，树中结点的各子树从左至右是有次序的，不能互换
- 无序树：逻辑上看，树中结点的各子树从左至右是无次序的，可以互换

树、森林

森林：森林是m（m≥0）棵互不相交的树的集合（m=0时是空森林）
<森林和树可以相互转换：森林里面的树拥有同一个根结点时森林转换成一棵树>

知识回顾：

![image-20230609222351548](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609222351548.png)

### 4.1.2.树的性质

1. **结点数=总度数+1**

   结点的度 —— 节点有几个孩子 

   “1”代表根结点

2. **度为m的树、m叉树的区别**

   树的度 —— 个结点的度的最大值

   m叉树 —— 每个节点最多只能由m个孩子

   ![image-20230609222916846](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609222916846.png)

3. 度为m的树第i层最多有![image-20230609223624602](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609223624602.png)个结点

   ![image-20230609223925057](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609223925057.png)

4. 高度为h的m叉树至多有![image-20230609224038751](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609224038751.png)个结点

5. 高度为h的m叉树至少有h个结点

   高度为h、度为m的树至少有h+m-1个结点

   ![image-20230609224435754](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609224435754.png)![image-20230609224559436](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609224559436.png)

6. 具有n个结点的m叉树的最小高度为![image-20230609224749575](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609224749575.png)

   

   知识回顾：

   ![image-20230609225117231](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609225117231.png)

   

## 4.2.二叉树

### 4.2.1.二叉树的定义和基本术语

![image-20230609225249067](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609225249067.png)

**二叉树的基本概念**

二叉树是n (n≥0) 个结点的有限集合：
①或者为空二叉树，即n=0
②或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树
![image-20230609225708010](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609225708010.png)

特点：①每个节点最多只有两棵子树②左右子树不能颠倒（二叉树是有序树）

**几个特殊的二叉树**

**满二叉树** —— 一棵树高度为h，且含有![image-20230609230311790](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609230311790.png)个结点的二叉树
![image-20230609231105857](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609231105857.png)特点：①只有最后一层有叶子结点
           ②不存在度为1的结点
           ③按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1；结点i的父节点为[i/2]并且向下取整（如果有的话)

**完全二叉树** —— 当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应
![image-20230609231441963](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609231441963.png)
（满二叉树是一种特殊的完全二叉树)
特点：①只有最后两层可能有叶子节点
           ②最多只有一个度为1的结点
           ③按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1；结点i的父节点为[i/2]并且向下取整
           ④i≤[n/2]为分支节点，i>[n/2]为叶子节点

**二叉排序树** —— 一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树:
左子树上所有结点的关键字均小于根结点的关键字;
右子树上所有结点的关键字均大于根结点的关键字。
左子树和右子树又各是一棵二叉排序树。

多用于元素的排序和搜索
![image-20230609233305843](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609233305843.png)

**平衡二叉树** —— 树上任一结点的左子树和右子树的深度之差不超过1
平衡二叉树能有更高的搜索效率
![image-20230609233654861](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609233654861.png)

知识回顾：

![image-20230609233736701](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230609233736701.png)

### 4.2.2.二叉树的性质

1. 设非空二叉树中度为0、1和2的结点个数分别为n₀、n₁和n₂，则n₀=n₂+1（叶子结点比二分支结点多一个）
   理解：假设树中结点总数为n
              ①n=n₀+n₁+n₂
              ②n=n₁+2n₂+1（树的结点数=总度数+1）
2. ![image-20230610091618768](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610091618768.png)
3. ![image-20230610091651091](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610091651091.png)

**完全二叉树的常考性质**

1. 具有n个（n>0）结点的完全二叉树的高度h为 **㏒₂(n+1)** 或 **(㏒₂n)+1**
   ![image-20230610092342147](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610092342147.png)

   **h-1 < ㏒₂(n+1) ≤ h** 
   ![image-20230610093459766](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610093459766.png)
   **h-1 ≤ ㏒₂n < h** 

2. 对于完全二叉树，可以由结点数n推出度为0、1和2的结点个数为n₀、n₁和n₂

   完全二叉树最多只有一个度为1的结点，即 n₁=0或1
   n₀=n₂+1 → n₀+n₂=2n₂+1 一定是奇数
   ![image-20230610094250657](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610094250657.png)

### 4.2.3.二叉树的存储结构

![image-20230610094612935](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610094612935.png)

**二叉树的顺序存储结构**

```c++
#define MaxSize 100
struct TreeNode{
    ElemType value;       //结点中的数据元素
    bool isEmpty;         //结点是否为空
}

TreeNode t[MaxSize];
//定义一个长度为MaxSize的数组t，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点

for(int i=0;i<MaxSize;i++){    
    t[i].isEmpty=true;         //初始化时所有结点标记为空结点
}
//可以让t[0]位置保持空缺，从而保证数组下标和结点编号一致
```

![image-20230610095554770](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610095554770.png)

几个常考的基本操作：
![image-20230610100012475](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610100012475.png)

如果不是完全二叉树，依然按层序将各结点进行顺序存储是不能从结点编号反映出结点间的逻辑关系的
![image-20230610100905681](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610100905681.png)
![image-20230610101121797](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610101121797.png)

![image-20230610101019983](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610101019983.png)
![image-20230610101056060](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610101056060.png)

如果把二叉树的结点编号与完全二叉树对应起来，就可以通过结点之间的编号来确定结点之间有没有存在某种逻辑关系
但是**不能**用以下方法判断是否有左孩子、右孩子和是否是叶子/分支结点（因为总结点数不是n）
![image-20230610101600736](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610101600736.png)
只能用  **is.Empty=true;**来判断

如果采用这种方法来存储二叉树会导致大量空间闲置，最坏的情况是高度为h且只有h个结点的单支树（所有结点只有右孩子），所占用的存储空间和满二叉树一样大

**结论：二叉树的顺序存储结构，只适合存储完全二叉树**

**二叉树的链式存储**

```c++
typedef struct BiTNode{
    ElemType data;                     //数据域
    struct BiTNode *lchild,*rchild;    //左、右孩子指针
}BiTNode,*BiTree;

//假如一个二叉树有n个结点，就会有2n个指针域，其中有n-1个数据有前驱指针
//所以n个结点的二叉链表共有n+1个空链域（可以用于构造线索二叉树）
```

![image-20230610102632627](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610102632627.png)

p43链式存储的实现代码。。。。

## 4.3.二叉树的遍历

遍历：按照某种次序把所有结点都访问一遍

层次遍历：基于树的层次特性确定的次序规则

先/中/后序遍历：基于树的递归特性确定的次序规则

### 4.3.1.二叉树的先中后序遍历

先/中/后序遍历：基于树的递归特性确定的次序规则

二叉树的递归特性：
①要么是一个空二叉树
②要么就是由“根结点+左子树+右子树”组成的二叉树

**先序遍历：根左右（NLR）**
**中序遍历：左根右（LNR）**
**后序遍历：左右根（LRN）**

![image-20230610105354100](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610105354100.png)

```c++
typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

//先序遍历
void PreOrder(BiTree T){
                                //若二叉树为空，则什么也不做
    if(T!=NULL){                //若二叉树为非空，则进行以下操作        
        visit(T);               //访问根结点
        PreOrder(T->lchild);    //递归遍历左子树
        PreOrder(T->rchild);    //递归遍历右子树
    }
}

//中序遍历
void InOrder(BiTree T){
    if(T!=NULL){                //若二叉树为非空，则进行以下操作
        InOrder(T->lchild);     //递归遍历左子树
        visit(T);               //访问根结点
        InOrder(T->rchild);     //递归遍历右子树
    }
}

//后序遍历
void PostOrder(BiTree T){
    if(T!=NULL){                //若二叉树为非空，则进行以下操作
        PostOrder(T->lchild);   //递归遍历左子树
        PostOrder(T->rchild);   //递归遍历右子树
        visit(T);               //访问根结点
    }
}

//空间复杂度：O(h)
```

**原理：函数调用栈**

```c++
//求树的深度
int treeDepth(BiTree T){
    if(T == NULL)
        return 0;
    else{
        int l = treeDepth(T->lchild);
        int r = treeDepth(T->rchild);
        //树的深度=Max(左子树深度，右子树深度)+1
        return l>r ? l+1 : r+1;
    }
}
```

###  4.3.2.二叉树的层序遍历

![image-20230610112827111](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610112827111.png)

![image-20230610113825398](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610113825398.png)

```c++
//层序遍历
void LevelOrder(BiTree T){ 
    LinkQueue Q;                     //使用链队列，因为树的结点未知
    InitQueue(Q);                    //初始化辅助队列
    Bitree p;
    EnQueue(Q,T);                    //将根结点入队
    while(!IsEmpty(Q)){              //队列不空则循环
        DeQueue(Q,p);                //队头结点出队
        visit(p);                    //访问出队结点
        if(p->lcild!=NULL)           
            EnQueue(Q,p->lchild);    //左孩子入队
        if(p->rcild!=NULL)
            EnQueue(Q,p->rchild);    //右孩子入队
    }
}
```

### 4.3.3.由遍历序列构造二叉树

![image-20230610173957070](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610173957070.png)

给定一个中序遍历序列并不能确定所对应的二叉树的形态
**结论：一个中序遍历序列可能对应多种二叉树形态**

![image-20230610174205791](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610174205791.png)

![image-20230610174245584](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610174245584.png)

![image-20230610174259594](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610174259594.png)

**结论：若只给出前/中/后/层 序遍历序列中的一种，不能唯一确定一棵二叉树**

![image-20230610174420539](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610174420539.png)

**前序+中序遍历序列**
![image-20230610175213746](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610175213746.png)

**后序+中序遍历序列**
![image-20230610175252650](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610175252650.png)

**层序+中序遍历**
![image-20230610175848436](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610175848436.png)

**结论：关键是找到根结点，必须要有中序遍历**

## 4.4.线索二叉树

### 4.4.1.线索二叉树的概念

普通二叉树：找前驱、后继很不方便：遍历操作必须从根开始

**中序线索二叉树**

由二叉树的链式存储可知：假如一个二叉树有n个结点，就会有2n个指针域，其中有n-1个数据有前驱指针，所以n个结点的二叉链表共有n+1个空链域
**可以利用这些空链域指向各个结点的前驱和后继**（让左孩子指针指向前驱，右孩子指针指向后继）

![image-20230610223821601](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610223821601.png)

如果一个结点的左孩子指针和右孩子指针指向的是前驱和后继而不是它的左右孩子，就将这种类型的指针称为线索

```c++
typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag,rtag;
}ThreadNode,*ThreadTree;
//tag==0,表示指针指向孩子
//tag==1,表示指针是“线索”
```

![image-20230610224611772](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610224611772.png)

![image-20230610224638534](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610224638534.png)

**先序线索二叉树**

![image-20230610224911225](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610224911225.png)

![image-20230610224928007](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610224928007.png)

**后序线索二叉树**

![image-20230610225116458](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610225116458.png)

![image-20230610225143220](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610225143220.png)

知识回顾

![image-20230610225358364](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230610225358364.png)

### 4.4.2.二叉树的线索化

**中序线索化**

找到一个结点的前驱

**比较原始的方法：**

```c++
typedef struct BiTNode{
    ElemType data;                     
    struct BiTNode *lchild,*rchild;    
}BiTNode,*BiTree;

//辅助全局变量，用于查找结点p的前驱pre
BiTNode *p=NULL;         //p指向目标结点
BiTNode *pre=NULL;       //pre指向当前访问结点的前驱
BiTNode *final=NULL;     //用于记录最终结果

//中序遍历
void InOrder(BiTree T){
    if(T!=NULL)
    {
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
}

//访问结点q
void visit(BiTNode *q){
    if(q==p)             //当前访问的结点刚好是p
        final=pre;       //找到p的前驱
    else                 
        pre=q;           //pre指向当前访问的结点
}
    
```

**中序线索化二叉树**

```c++
typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild,*rchild;
    int ltag,rtag;
}ThreadNode,*ThreadTree;

//中序遍历二叉树，一边遍历一边线索化
void InThread(ThreadTree T){
    if(T!=NULL){
        InThread(T->lchild);
        visit(T);
        InThread(T->rchild);
    }
}

ThreadNode *pre=NULL;//全局变量pre，当前访问节点的前驱

void visit(ThreadNode *q){
    if(q->lchild==NULL){     //左子树为空，建立前驱线索
        q->lchild=pre;
        q->ltag=1;
    }
    if(q->lchild！=NULL&&q->rchild==NULL){     
        pre->lchild=q;
        per->rtag=1;
    }
    pre=q;
}

//最后一个结点还需要进行特别的检查，看pre的rchild是否为NULL，若果是，则令rtag=1
```

![image-20230612102018738](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230612102018738.png)

**先序线索化**

**后序线索化**

p48...

![image-20230612102610754](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230612102610754.png)

**在线索二叉树中找前驱后继**

p49...

## 4.5.树（2.0）

### 4.5.1.树的存储结构

![image-20230612103031604](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230612103031604.png)

**双亲表示法（顺序存储）**

除了根节点之外，树里面的任意一个结点都有且仅有一个双亲结点（父结点）

![image-20230612103521706](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230612103521706.png)

**双亲表示法：每个结点中保存指向双亲的“指针”**

![image-20230612103547949](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230612103547949.png)

```c++
#define MAX_TREE_SIZE 100           //树中最多结点数
typedef struct{                     //树的结点定义
    ElemType data;                  //数据元素
    int parent;                     //双亲位置域
}PTNode;

typedef struct{                     //树的类型定义
    PTNode nodes[MAX_TREE_SIZE];    //双亲表示
    int n;                          //结点数
}PTree;
```

添加元素：明确双亲结点并保存指向双亲结点的指针
                  结点数n+1

删除元素：①将要删除的元素的指向双亲结点的指针改为-1
                  ②将后面所添加的元素补在删除元素原来所在的存储空间上
                  结点数n-1
                  如果删除的不是叶子节点，而是分支节点（就相当于删除一颗子树）

双亲表示法：优点：查指定结点的双亲很方便
                      缺点：查指定结点的孩子只能从头遍历

**孩子表示法（顺序+链式存储）**

p50...~p54

# 5.图

## 5.1.图的基础

### 5.1.1.图的基本概念

**图的定义**

图G由**顶点集V**和**边集E**组成，记为G=(V,E)，其中V(G)表示图G中顶点的有限非空集; E(G)表示图G中顶点之间的关系 (边) 集合。若V={v₁, v₂,...,v}，则用 |V| 表示图G中**顶点的个数**，也称**图G的阶**，E={(u, v) | u∈V, v∈V}，用 |E| 表示图G中边的条数

**注意：线性表可以是空表，树可以是空树，但图不可以是空，即V一定是非空集，但是一个图的边集可以是空集**

![image-20230613122623248](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613122623248.png)

**无向图和有向图**

![image-20230613122855652](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613122855652.png)

**简单图和多重图（但是数据结构只探讨简单图）**

![image-20230613123355181](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613123355181.png)![image-20230613123444201](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613123444201.png)

**顶点的度、入度、出度**

对于无向图：顶点v的度是指依附于该顶点的边的条数，记为TD(v)

对于有向图：①入度是以顶点v为终点的有向边的数目，记为ID(v)
                      ②出度是以顶点v为起点的有向边的数目，记为OD(v)
                      ③顶点的度等于其入度和出度之和，即TD(v)=ID(v)+OD(v)
![image-20230613124500416](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613124500416.png)

**顶点与顶点关系的描述**

- **路径** —— 顶点v1到顶点vn之间的一条路径是指顶点序列
  (无向图中路径方向没有限制，但是在有向图中路径的方向必须和弧的方向是一致的)
- **回路** —— 第一个顶点和最后一个顶点相同的路径称为回路或环
- **简单路径** —— 在路径序列中，顶点不重复出现的称为简单路径
- **简单回路** —— 除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路
- **路径长度** —— 路径上 边的数目
- 顶点到顶点的**距离** —— 从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到v的距离。若从u到v根本不存在路径，则记该距离为无穷 (∞)
- 无向图中，若从顶点v到顶点w有路径存在，则称v和w是**连通**的
- 有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是**强连通**的

![image-20230613130040989](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613130040989.png)

**连通图常见考点：**
![image-20230613130439267](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613130439267.png)

**强连通图常见考点：**
![image-20230613130329331](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613130329331.png)

**子图——研究图的局部**

![image-20230613130713896](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613130713896.png)

![image-20230613130733739](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613130733739.png)

**连通分量**

无向图中的**极大连通子图**（子图必须连通，且包含尽可能多的顶点和边）称为连通分量
![image-20230613131057418](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613131057418.png)

**强连通分量**

有向图中的极大强连通子图（子图必须强连通，同时保留尽可能多的边）称为有向图的强连通分量
![image-20230613131333652](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613131333652.png)

**生成树**

无向图中连通图的生成树是包含图中全部顶点的一个极小连通子图（边尽可能少，但要保持连通）
![image-20230613131642394](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613131642394.png)

**生成森林**

在非连通图中，**连通分量的生成树**构成了非连通图的生成森林
![image-20230613131937207](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613131937207.png)

**边的权、带权图/网**

- 边的权 —— 在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。（eg.实际距离）
- 带权图/网 —— 边上带有权值的图称为带权图，也称网。
- **带权路径长度** —— 当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度

**几种特殊形态的图**

- **无向完全图** —— 无向图中任意两个顶点之间都存在边

  ![image-20230613132811723](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613132811723.png)

  ![image-20230613132628617](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613132628617.png)

- **有向完全图** —— 有向图中任意两个顶点之间都存在方向相反的两条弧

  ![image-20230613132901320](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613132901320.png)

  若有向图的顶点个数 |V| =n，则![image-20230613133037350](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613133037350.png)

- 稀疏图

- 稠密图

- **树** —— 不存在回路，且连通的无向图（n个顶点的树，必有n-1条边）
  ![image-20230613133223037](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613133223037.png)
  ![image-20230613133431344](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613133431344.png)

  ![image-20230613133518645](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613133518645.png)
  有向树并不是强连通图

知识回顾

![image-20230613133710894](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230613133710894.png)

## 5.2.图的存储结构

### 5.2.1.邻接矩阵法

“0”表示两个顶点之间相互不邻接，“1”表示的时两个顶点之间相互是邻接的

无向图和有向图的邻接关系不同

![image-20230618082256152](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618082256152.png)

```c++
#define MaxVertexNum 100                  //顶点数目的最大值      
typedef struct{
    char Vex[MaxVertexNum];               //顶点表
    //顶点中不一定存放字符类型，可以存放更复杂的信息
    int Edge[MaxVertexNum][MaxVertexNum]; //二维数组定义邻接矩阵，边表
    int vexnum,arcnum;                    //图的当前顶点数和边数/弧数
}
```

无向图的度：第i个结点的度 = 第i行（第i列）的非零元素个数 <时间复杂度为O(n)，n是顶点的个数>

有向图：①第i个结点的出度 =第i行的非零元素个数
               ②第i个结点的入度 =第i列的非零元素个数
               ③第i个结点的度 =第i行、第i列的非零元素个数之和

 邻接矩阵法求顶点的**度/出度/入度**的时间复杂度为O(n)【O(|v|)】，n是顶点的个数

**邻接矩阵法存储带权图（网）**

在邻接矩阵中的“0”和“∞”代表两个顶点之间相互不邻接

![image-20230618084003728](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618084003728.png)

![image-20230618083941390](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618083941390.png)

邻接矩阵法的**空间复杂度**为O(n)+O(n²)=O(n²) 【**O(|v|²)**】——只和顶点数有关，和实际的边无关

如果图的顶点数很多，但是边数很少的话会浪费大量空间，所以邻接矩阵**适合用于存储稠密图**

无向图的邻接矩阵是对称矩阵，可以压缩存储（只存储上三角区/下三角区）

![image-20230618084744091](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618084744091.png)

![image-20230618090008404](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618090008404.png)

**邻接矩阵法要点回顾**

![image-20230618090108345](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618090108345.png)

### 5.2.2.邻接表法（顺序+链式存储）

![image-20230619163139738](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619163139738.png)

![image-20230618091611241](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618091611241.png)

### 5.2.3. 十字链表法  -  邻接多重表

十字链表法：存储有向图
邻接多重表：存储无向图

![image-20230618093046457](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618093046457.png)

### 5.2.4.图的基本操作

![image-20230618093242103](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618093242103.png)

## 6.4.图的遍历算法

### 6.4.1.广度优先遍历

### 6.4.2.深度优先遍历



# 6.查找

## 6.1.查找的基本概念

### 6.1.1.基本概念

- 查找 —— 在数据集合中**寻找**满足某种条件的数据元素的过程称为查找
- 查找表(查找结构) —— 用于查找的数据集合称为查找表，它由同一类型的数据元素(或记录)组成
- 关键字 —— 数据元素中**唯一**标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的

![image-20230618231700322](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618231700322.png)

![image-20230618231834532](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618231834532.png)

**对查找表的常见操作**
①查找符合条件的数据元素
②插入、删除某个数据元素
![image-20230618232201365](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618232201365.png)



### 6.1.2.查找算法的效率评价

**查找长度** —— 在查找运算中，需要对比关键字的次数称为查找长度

**平均查找长度**(**ASL**,Average Search Length) —— 所有查找过程中进行关键字的比较次数的平均值（**ASL的数量级反应了查找算法时间复杂度**）

![image-20230618232421412](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618232421412.png)

评价一个查找算法的效率时,通常考虑查找成功/查找失败两种情况的 ASL

![image-20230618232808007](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618232808007.png)

![image-20230618232827274](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618232827274.png)

## 6.2.常见查找算法

### 6.2.1.顺序查找

**算法思想**

![image-20230618233240387](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618233240387.png)

**算法实现 —— 时间复杂度O(n)**

![image-20230618233455687](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618233455687.png)

![image-20230618234027477](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618234027477.png)

**算法优化**

- 优化一![image-20230618234522759](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618234522759.png)

  ![image-20230618234543735](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618234543735.png)

- 优化二![image-20230618234739971](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618234739971.png)

![image-20230618235025364](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230618235025364.png)

### 6.2.2.折半查找

**算法思想**

折半查找，又称“二分查找”，**仅适用于有序的顺序表(顺序表拥有随机访问的特性，链表没有)**

**算法实现 —— 时间复杂度O(㏒₂n)**

![image-20230619000519969](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619000519969.png)

![image-20230619001414820](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619001414820.png)

**折半查找判定树**

![image-20230619001621710](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619001621710.png)

右子树结点数与左子树相等或者只多一个，不可能比左子树少

折半查找的判定树一定是**平衡二叉树**

![image-20230619002233092](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619002233092.png)

知识回顾

![image-20230619002458734](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619002458734.png)

### 6.2.3.分块查找（选择题居多）

**算法思想**

![image-20230619003156461](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619003156461.png)

特点：块内无序，块间有序

**算法实现 **

![image-20230619003330257](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619003330257.png)

分块查找，又称索引顺序查找，算法过程如下：
①在索引表中确定待查记录所属的分块 (**可顺序、可折半**)
②在块内顺序查找

![image-20230619092419656](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619092419656.png)

**算法效率**

![image-20230619093701005](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619093701005.png)

![image-20230619094003692](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619094003692.png)

**n=s·b**

![image-20230619094204763](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619094204763.png)

即当长度为n的查找表被均匀地分为 √n 块，每块有 √n 个元素时，平均查找长度最短

知识回顾

![image-20230619094605415](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619094605415.png)

## 6.3.二叉树的应用

### 6.3.1.二叉排序树

**二叉排序树的定义**

二又排序树，又称二又查找树(**BST**，Binary Search Tree)
一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树:
**左子树上所有结点的关键字均小于根结点的关键字**；
右子树上所有结点的关键字均大于根结点的关键字
左子树和右子树又各是一棵二又排序树。

**特点：左子树结点值 < 根结点值 < 右子树结点值**所以用**中序遍历可以得到一个递增的有序序列**

![image-20230619095415461](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619095415461.png)

**二叉排序的查找**

![image-20230619095802556](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619095802556.png) 

若树非空，目标值与根结点的值比较；
若相等，则查找成功;若小于根结点，则在左子树上查找，否则在右子树上查找。
查找成功，返回结点指针；查找失败返回NULL

![image-20230619095914575](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619095914575.png)

 **二叉排序树的插入**

若原二又排序树为空，则直接插入结点；否则，若关键字k小于根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树(新插入的结点一定是叶子)

![image-20230619100434265](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619100434265.png)

**二叉排序树的构造**

![image-20230619100720673](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619100720673.png)

**二叉排序树的删除**

先搜索找到**目标结点**:
①若被删除结点z是叶结点，则直接删除，不会破坏二又排序树的性质
②若结点z只有一棵左子树或右子树则让z的子树成为z父结点的子树，替代z的位置
③ 若结点z有左、右两棵子树，则令z中序遍历的直接后继 (或直接前驱) 替代z，然后从二叉排序树中删去这个直接后继(或直接前驱)，这样就转换成了第一或第二种情况。(就是找左子树的最大值或右子树的最小值)

**查找效率分析**

查找长度 —— 在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度 

![image-20230619102006195](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619102006195.png)

要尽量使树的高度最小，才能使时间复杂度最低，所以可以采用平衡二叉树(树上任一结点的左子树和右子树的深度只差不超过1)

知识回顾

![image-20230619102500212](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619102500212.png)

### 6.3.2.平衡二叉树(AVL)

**定义**

平衡二叉树，简称平衡树(AVL树) —— 树上任一结点的左子树和右子树的高度之差不超过1

结点的平衡因子 = 左子树高 - 右子树高（平衡二叉树结点的平衡因子的值只可能是-1、0 或 1 ）

![image-20230619102924912](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619102924912.png)

**⭐插入新结点后如何调整不平衡问题**

![image-20230619103229346](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619103229346.png)

让最小不平衡子树恢复平衡之后，其他祖先结点也都恢复平衡了

最小不平衡子树的几种情况
![image-20230619103426933](C:\Users\于采卉\AppData\Roaming\Typora\typora-user-images\image-20230619103426933.png)

- 调整最小不平衡子树(LL)

**查找效率分析**

